---
title: "Git TP ENSAI"
description: "TP de découverte de Git"
author: Ludovic Deneuville, Rémi Pépin
format: 
  html:
    toc: true
    toc-location: left
    toc-expand: 3
from: markdown+emoji
number-sections: true
lightbox: true
---

## À faire à la maison{.unnumbered}

::: {.callout-note}
Les consignes de ce TP sont données pour une utilisation de GitHub. Il est cependant tout à fait possible de réaliser ce TP avec GitLab dont l'interface est très ressemblante.

:warning: Il y a tout de même quelques différences :

- GitHub Repository = GitLab Projet
- Pour déclarer la clé SSH dans GitLab : cliquez sur votre avatar > Préférences > SSH keys

:::

- [ ] Créer un compte sur [GitHub](https://github.com/){target="_blank"}
  - GitHub > Sign up 
  - ou avec [ce lien direct](https://github.com/signup){target="_blank"}
- [ ] Lire l'introduction


## Introduction {.unnumbered}

Git est un formidable outil de versionnage de fichiers qui va vous permettre de conserver efficacement l'historique de votre code aussi bien si vous travaillez seul mais également quand vous travaillez à plusieurs.
Cet historique est conservé dans ce qu'on appelle un *dépôt git*.

Sa conception décentralisée fait qu'il est quasi impossible de perdre une donnée définitivement avec git. En particulier, la perte totale d'un ordinateur hébergeant votre code ne représentera qu'une perte minime de code si vous utilisez git correctement.

En outre, de nombreux outils de *CI/CD* (*Continuous Intégration / Continuous Deployment*) qui rendent possible l'automatisation de l'intégration et du déploiement de votre code s'appuient sur un *dépôt git*.

### Concepts Clés {.unnumbered}

Cependant, comme tout logiciel, git demande un peu d'apprentissage, et de la pratique. Pour commencer, nous aurons besoin de certains concepts essentiels pour une utilisation efficace. Par sa conception décentralisée, un dépôt git peut exister en plusieurs endroits en même temps : sur notre machine, sur chaque machine des membre du projet, ou sur un serveur hébergeant le projet.

On parlera de la *copie distante* (*remote* en anglais) du dépôt dans le cas du serveur distant. En général, une seule copie distante est utilisée, mais par sa nature décentralisée, plusieurs copies distantes sont possibles (possibilité non incluse dans ce TP).

La copie sur notre machine est la *copie locale* (*local* en anglais). Il s'agit de toutes les informations du dépôt concernant l'historique de ses fichiers, et les métadonnées du dépôt. Une distinction subtile est alors faite entre la copie locale et la *copie de travail* (*working copy* en anglais) : Nos modifications sur les fichiers du dépôt n'intégrerons la copie locale qu'à notre demande explicite. Cette intégration sera alors effectuée par l'ajout d'une entrée à l'historique du dépôt.

### Programme {.unnumbered}

Pour utiliser git, donc pour gérer un dépôt, nous avons accès à de nombreuses commandes.
Pour ce TP de découverte vous allez utiliser seulement les commandes suivantes :

| Commande                    | Description                              |
|-----------------------------|------------------------------------------|
| `git clone <adr>`           | Créer un dépôt local sur son poste       |
| `git status`                | Voir où l'on en est                      |
| `git add <file>`            | Ajouter pour le prochain commit          |
| `git commit -m "<msg>"`     | Créer un point de sauvegarde             |
| `git pull`                  | dépôt local :arrow_right: dépôt distant  |
| `git push`                  | dépôt local :arrow_left: dépôt distant   |


## Git Bash et Unix

Avant de nous lancer avec git, prenons quelques minutes pour découvrir le terminal Git Bash et les principales commandes Unix.

Ces commandes ne sont pas indispensable pour utiliser git, mais il est utile et préférable de les connaitre.

- [ ] Cliquez sur l'icone Windows (ou Menu Démarrer) et ouvrez l'application `Git Bash`
  - cela ouvre un terminal

![](img/git-bash.PNG){.r-stretch}


Pour vous aider, voici la [liste des commandes](presentation.html#commandes-unix){target="_blank"}.

### Création d'une arborescence

- [ ] Affichez le répertoire courant
- [ ] Positionnez-vous sur le disque *P:* (`/p`)
- [ ] Listez les fichiers
- [ ] S'il n'existe pas, créez un dossier nommé `Cours1A`
- [ ] Positionnez-vous dans le dossier *Cours1A*
- [ ] Créez un dossier nommé `git-initiation`
- [ ] Positionnez-vous dans le dossier *git-initiation*

::: {.callout-tip collapse="true" title="Solution"}
- `pwd`
- `cd /p`
- `ll`
- `mkdir Cours1A`
- `cd Cours1A`
- `mkdir git-initiation`
- `cd git-initiation`

Il était également possible de tout faire d'une seule traite :

- `mkdir -p /p/Cours1A/git-initiation && cd $_`
- l'option -p de *mkdir* crée tous les dossiers et sous-dossiers s'ils n'existent pas déjà
- *$\_* : correspond au dernier argument de la commande précédente
:::

### Les fichiers

- [ ] Créez un fichier *a.txt* contenant le résultat de la commande `ps` 
  - ps liste tous les processus en cours
  - `ps > a.txt`
- [ ] Créez une copie de ce fichier que vous nommerez *b.txt*
- [ ] Listez les fichiers du dossier courant
- [ ] Affichez le contenu du fichier *b.txt*
- [ ] Filtrez le contenu du fichier *b.txt* pour n'afficher que les lignes contenant *ps*
  - `cat b.txt | grep ps`
- [ ] Renommez le fichier *a.txt* en *c.txt*
- [ ] Listez les fichiers du dossier courant
- [ ] Supprimez les fichiers *b.txt* et *c.txt*
- [ ] Créez 5 fichiers avec la commande `touch ex{1..5}.py`
- [ ] Listez les fichiers du dossier courant
- [ ] Supprimez ces 5 fichiers avec la commande `rm ex*.py`
- [ ] Créez un fichier avec la commande `touch setup-git.sh`

## Paramétrage de Git


### Configuration

- [ ] Dans l'explorateur de fichiers Windows (WIN + E), allez dans le dossier `P:/Cours1A/git-initiation`
- [ ] Ouvrez le fichier *setup-git.sh* avec **Notepad++** et collez ce contenu
  ```{.bash filename="setup-git.sh"}
  git config --global user.name "Prenom Nom"
  git config --global user.email prenom.nom@eleve.ensai.fr
  git config --global credential.helper store
  git config --global core.mergeoptions --no-edit
  git config --global core.editor "code -w"
  ```
- [ ] Remplacez *Nom* et *Prenom* sur les deux premières lignes et enregistrez
- [ ] Dans Git Bash, exécutez le fichier : `./setup-git.sh`
- [ ] Vérifiez que la configuration est correcte avec `git config -l`


### Création d'une clé SSH

Pour permettre de faire dialoguer notre dépôt local avec le dépôt distant de GitHub, nous allons utiliser le protocole `ssh` :

- Nous allons générer une clé sur notre machine
- Nous allons ensuite déclarer cette clé à GitHub

::: {.callout-warning}
Ce paramètrage SSH est réalisé au niveau de la machine.

Si par exemple, vous souhaitez utiliser Git sur votre ordinateur personnel, il faudra faire également ce paramétrage.
:::

Dans Git Bash :

- [ ] Créez un dossier *`*/c/Users/id????.ssh* pour stocker votre clé ssh
  - `mkdir -p ~/.ssh`
- [ ] Créez une clé ssh
  - `ssh-keygen -t rsa -b 4096 -N '' -q -f ~/.ssh/id_rsa`
- [ ] Copiez le contenu de la clé publique
  - `cat ~/.ssh/id_rsa.pub | clip`
  - c'est comme si vous copiez le contenu du fichier *id_rsa.pub*

Déclarez votre clé publique à *GitHub*, pour pouvoir ensuite faire communiquer dépôts locaux avec les dépôts distants :

- [ ] GitHub > cliquez sur votre avatar > Settings > SSH and GPG keys
  - [lien direct](https://github.com/settings/keys){target="_blank"}
- [ ] Cliquez sur [New SSH key]{style="background-color: green"}
  - Title : VM ENSAI
  - Key : Collez votre clé publique
  - [Add SSH key]{style="background-color: green"}



::: {.callout-note title="SSH : Comment ça marche ?" collapse="true"}

SSH (Secure Shell) est un protocole permettant de se connecter à un autre ordinateur sur un réseau de manière sécurisée.

SSH chiffre toutes les informations échangées afin de protéger les données.

SSH utilise un mécanisme de clés cryptographiques pour authentifier les ordinateurs et les utilisateurs, garantissant que la connexion est effectuée avec le bon serveur et sans intervention malveillante :

- `Clé privée` : C'est comme la clé de votre maison. Vous la gardez en sécurité avec vous et ne la partagez avec personne. Cette clé reste sur votre ordinateur et sert à prouver votre identité.
- `Clé publique` : Elle serait comme votre adresse postale. Vous pouvez la partager avec d'autres. Dans SSH, vous placez votre clé publique sur les serveurs ou les ordinateurs auxquels vous souhaitez vous connecter.

Ces deux clés sont liées. Un message chiffré par la clé publique n'est déchiffrable que par celui qui posséde la clé privée.
Lorsque vous chiffrez un message avec votre clé privée, vous prouvez à tous votre identité car chacun peut déchiffrer ce message avec la clé publique.

{{< video https://www.youtube.com/watch?v=Y-S6GtdLaSU&ab_channel=Grafikart.fr >}}

:::



### Le terminal Git Bash

- [ ] Allez dans le dossier `P:/Cours1A/Git`
- [ ] Clic droit > *Git Bash here*
- Créez un dossier *depot1* et entrez dans ce dossier
  - [ ] `mkdir depot1` pour *make directory*
  - [ ] `cd depot1` pour *change directory*
- Afficher le chemin du répertoire courant avec la commande `pwd` : *print working directory*
- [ ] `cd ..` pour retourner dans le dossier parent
- [ ] créer un dossier depot2


## Créez un dépôt distant

- [ ] Créez un [nouveau Repository](https://github.com/new){target="_blank"} sur GitHub
  - GitHub > Repositories > [New]{style="background-color: green"}
  - Repository name : *tp-git*
  - Visibility Level : *Private*
  - Cochez *Add a README file*
  - Add .gitignore : *Python*
  - Choose a license : *MIT Licence*
  - Cliquez sur [Create Repository]{style="background-color: green"}


## Créez un dépôt local

Suite à la création de votre compte GitHub, vous avez créé un repo (i.e. un dépôt distant).

Vous allez maintenant créer une copie locale de ce dépôt en clonant ce projet. 

Sur la page GitHub de votre repo, 

- [ ] Cliquez sur [Code]{style="background-color: green"}
- [ ] Copiez la ligne *Clone with SSH*
- [ ] Dans Git Bash, vérifiez que vous êtes dans le dossier *p/Cours1A/git-initiation*
  - si ce n'est pas le cas : `cd /p/Cours1A/git-initiation`
- [ ] Entrez `git clone <collez la ligne>`
  - exemple : `git clone git@github.com:ludo2ne/tp-gitzzz.git`
- [ ] Listez le contenu du répertoire courant
  - Le dossier *tp_initiation_git* est bien présent
  - vous pouvez également vérifier sa présence via l'explorateur Windows 
    - WIN + E, puis allez à `P:\Cours1A\git-initiation`
- [ ] Positionnez-vous dans le dépôt : `cd tp_initiation_git`
  - à la fin de votre prompt, vous remarquerez l'apparition de [(main)]{style="color: cyan"}
  - cela signifie que vous êtes dans un dépôt git, sur la branche principale

Vous pouvez fermer *Git Bash*.

Vous allez par la suite utiliser le *Git Bash* (exactement le même) qui est intégré dans l'IDE [Visual Studio Code](https://code.visualstudio.com/){target="_blank"}.

::: {.callout-tip}
Un IDE (Integrated Development Environment) est une application qui offre des outils complets pour le développement logiciel

Les composants principaux d'un IDE :

- Éditeur de Code
- Compilateur / Interpréteur
- Gestionnaire de Projet
- Terminal Intégré
:::


## Configuration de VSCode :construction:


- [ ] Ouvrez l'application `Visual Studio Code`
- :gear: en bas à gauche > Settings
- [ ] Fermez pour réouvrez VSCode pour valider la config

??? Niveau user ou workspace ???

```{.json filename="User settings"}
{
    "files.exclude": {
        "**/__pycache__": true
    },
    "git.openRepositoryInParentFolders": "never",
    "terminal.integrated.defaultProfile.windows": "Git Bash",
    "editor.inlayHints.enabled": "off",
    "java.configuration.runtimes": [],
}
```

## Votre dépôt local dans VSCode

- [ ] File > Open Folder
  - Allez dans *P:\Cours1A\git-initiation*
  - Cliquez [une seule fois]{.underline} sur le dossier *tp-git*
  - `Séletionner un dossier`
  - *Yes I trust the authors*
  - :warning: dans votre explorer en haut à gauche, le dossier parent doit être *tp-git*
    - si ce n'est pas le cas, recommencez l'Open Folder
- [ ] Ouvrez un terminal *Git Bash*
  - Terminal > New Terminal (CTRL + ù)

## Premiers pas avec Git

- [ ] Créez un dossier `src`
  - dans VSCode > clic droit dans l'Explorer > New Folder
  - ce dossier contiendra vos programmes
- [ ] Créez également à la racine, les dossiers `data` et `doc`
- [ ] Créez un fichier `voiture.py`
  - dans le dossier *src*
  - ouvrez ce fichier et collez ce code 
  ```{.python filename="voiture.py"}
  class Voiture:
      """Classe représentant une voiture.
      
      Attributes
      ----------
      nom : str
          le nom de la voiture.
      couleur : str
          la couleur de la voiture.
      vitesse : int
          la vitesse de la voiture (initalisée à 0).
      """

      def __init__(self, nom, couleur):
          """Constructeur"""
          self.nom = nom
          self.couleur = couleur
          self.vitesse = 0
      
      def __str__(self):
        return f"La voiture {self.nom} de couleur {self.couleur} roule à {self.vitesse} km/h."
  
  ```

Dans le terminal *Git Bash* intégré dans VScode, exécutez les commandes suivantes : 

- [ ] `git status`
  - différences entre la version de travail du code et le commit le plus récent
  - le dossier `src` apparait dans *Untracked files*
  - cela signifie que Git a repéré ce dossier mais qu'il ne le versionnera pas
- [ ] `git add src`
  - pour faire reconnaitre ce dossier et le placer la zone de transit
  - ce dossier et ses fichiers seront versionnés dans le prochain commit
- [ ] `git status`
  - maintenant le fichier est reconnu par Git
- [ ] `git commit -m "Création classe voiture"`
  - permet de faire un commit = un point de sauvegarde pour git = une entrée supplémentaire à l'historique
  - entre les `" "`, mettez un message court et explicite. Ce message est obligatoire !
- [ ] `git status` : 
  - *Your branch is ahead of 'origin/main' by 1 commit*
  - votre dépôt local est en avance d'un commit par rapport au dépôt distant
- [ ] `git pull`
  - récupére les derniers commits disponibles sur le dépôt distant (sur GitHub) 
  - actuellement il n'y en a pas, mas il faut prendre l'habitude de souvent récupérer les derniers commits
- [ ] `git push`
  - pousse vos commits vers le dépôt distant. 
  - :warning: si vous avez modifiez des fichiers qui ne sont pas dans un commit, ces modifications n'apparaitront pas sur le dépôt distant

Allez sur la page GitHub de votre repo et vérifiez que vos fichiers sont bien arrivés.


- [ ] Ajouter à la fin du fichier `voiture.py` ce code et [enregistrez]{.underline}
  ```{.python filename="voiture.py"}
      def accelere(self, increment) -> None:
          """Augmente la vitesse de la voiture.

          L'incrément maximal est de 10 km/h.
          La Vitesse maximale est de 130 km/h.

          Parameters
          ----------
          increment : int
              la valeur de l'accélération demandée (limité à 10)
          """
          if increment > 10:
              increment = 10
          self.vitesse = min(130, self.vitesse + increment)
  ```

Dans le terminal *Git Bash*

- [ ] `git status`
  - le fichier *voiture.py* a été modifié
- [ ] `git diff` pour voir les différence depuis le dernier commit
  - *q* pour quitter
- [ ] `git add .` pour ajouter toutes les modifications de tous les fichiers au prochain commit
- [ ] Comme précédemment, faite un commit, et un push
  - pour créer un point de sauvegarde et l'envoyer vers le dépôt distant
- [ ] Regardez votre historique avec un `git log --all --decorate --oneline --graph`

Pour résumer voilà ce que vous avez fait :

:::white-box
![Zonge git](https://nceas.github.io/sasap-training/materials/reproducible_research_in_r_fairbanks/images/git-flowchart.png)
:::

## Exercice d'application 1

- [ ] Créez un fichier `fibonacci.py` avec ce code
  ```{.python filename="fibonacci.py"}
  def fibonacci(n):
      """Calcule le n ième terme de la suite de Fibonacci
      en utilisant un algorithme récursif.
      """ 
      if n < 2:
          return 1
      else :
          return fibonacci(n - 1) + fibonacci(n - 2)
  
  if __name__ == "__main__":
      for i in range (1, 15):
          print(fibonacci(i))
  ```
- [ ] Envoyez le sur la copie distante de votre projet GitHub
- [ ] Créez un fichier `puissance_rec.py` avec le code suivant
  ```{.python filename="puissance_rec.py"}
  def puissance_rec(nombre, puissance):
      if not puissance:
          return 1
      elif not puissance % 2:
          return puissance_rec(nombre, int(puissance / 2)) \
          * puissance_rec(nombre, int(puissance / 2))
      else:
          return nombre * puissance_rec(nombre, puissance - 1)
  ```
- [ ] Envoyez le sur la copie distante de votre projet GitHub
- [ ] Afficher votre historique


## Simulation de travail en groupe

Pour les questions suivantes, vous allez avoir besoin de 2 dépôts locaux et d'un dépôt distant. Il y a 2 possibilités : 

- soit vous travaillez en bînome (vous avez chacun votre dépôt local)
- soit vous faîtes seul (mais vous gérez 2 dépôts locaux différents)

:::{.callout-note title="Si vous travaillez à 2"}
Un des 2 membres va créer un dépôt local à partir du dépôt distant de l'autre.

- [ ] :frog: fournit à :cat: l'adresse ssh de son repo
- [ ] :frog: donne accès à :cat: à son repo
  - page GitHub du repo > Settings > Collaborators
  - [Add people]{style="background-color: green"}
- [ ] :cat: clone le dépôt distant
  - explorateur Windows > aller dans *P:/Cours1A/git-initiation/*
  - créez un dossier `depot2`, et entrez dans ce dossier
  - clic droit > Open Git Bash here
  - `git clone <adresse_ssh_depot_distant_de_frog>`
- [ ] :cat: ouvre ce dépôt avec VScode (File > Open Folder)
:::


:::{.callout-note title="Si vous faîtes seul"}
Dans l'explorateur Windows :

- [ ] Allez dans *P:/Cours1A/git-initiation*
- [ ] Créez un dossier `depot2`, et entrez dans ce dossier
- [ ] Clic droit > Open Git Bash here
- [ ] Créez un nouveau clone du dépôt distant
  - `git clone xxx` comme fait précédemment
- Vous avez donc 2 dépôts locaux distincts
  - *P:/Cours1A/git-initiation/tp-git* :frog:
  - *P:/Cours1A/git-initiation/depot2/tp-git* :cat:
  - ils sont indépendants mais tous deux reliés au dépôt distant
:::


Dans une des fenêtres créez un fichier `moto.py` avec le code suivant :

```{.python}
class Moto:
    def __init__(self, nom, couleur):
        self.couleur = couleur
        self.nom = nom
        self.vitesse = 0
        
    def accelere(self, increment):
        if increment > 15:
            increment = 15
        self.vitesse = min(150, self.vitesse + increment)
```

Puis dans le terminal de cette fenêtre faites les commandes `git add moto.py`, `git commit -m "creation classe moto"`, `git push`.

Maintenant allez dans l'autre fenêtre. Actuellement il n'y a pas le fichier `moto.py`. Il va nous falloir le récupérer.

1. Commencez par faire un `git fetch`. Cela va permettre de récupérer les modifications de la copie distante dans la copie locale, sans modifier la copie de travail (ici, `moto.py` ne va pas apparaître dans l'explorateur de fichier).

2. Ensuite faites un `git status`. Vous allez obtenir le message suivant `Your branch is behind 'origin/main' by 1 commit, and can be fast-forwarded. (use "git pull" to update your local branch)`. Cela signifie que votre copie de travail est en retard comparée à votre copie locale.

3. Faites un `git log --all --decorate --oneline --graph`. Vous devrez obtenir le résultat suivant (les valeurs des hash (les 7 caractères hexadécimaux au début) de commits peuvent être différentes :

   ```
   * aa02cb7 (origin/main) creation classe moto
   * a81a5a2 (HEAD -> main) add accelere fonction
   * 6e7c120 creation classe voiture
   * 49fdb53 Initial commit
   ```

   Actuellement le dernier commit de ma copie de travail est le commit `a81a5a` mais ma copie locale possède le commit `aa02cb7` qu'il me faut récupérer. `HEAD` permet de repérer où se trouve notre copie de travail par rapport à l'historique dans notre copie locale.

4. Faites un `git merge` maintenant. Cela va appliquer sur votre copie de travail les modifications additionnelles de votre copie locale. Par la suite nous allons remplacer les opérations `git fetch` et `git merge` par `git pull`.

   ```
   Updating a81a5a2..aa02cb7
   Fast-forward
    moto.py | 10 ++++++++++
    1 file changed, 10 insertions(+)
    create mode 100644 moto.py
   ```

5. Faites un `git log --all --decorate --oneline --graph` pour vérifier que vous avez bien récupéré la dernier version du code.

6. Créez un fichier `velo.py` et avec le même contenu que le fichier moto et faites les mêmes manipulations pour que le fichier apparaisse dans les deux fenêtres (donc dans vos deux copies de travail distinctes).

7. Maintenant créez un fichier dans chaque fenêtre VScode, dans la première vous allez faire un fichier `exo1.R` et dans l'autre vous allez créer un fichier `exo2.R` avec les codes suivants :

```R
# exo1.R
a<-c(10,5,3,2)
a[2]
a[3]
a[2:3]
```

```R
# exo2.R
b<-c(11,6,4,3)
b[2]
b[3]
b[2:3]
```

Faites un commit dans une fenêtre et poussez le code, puis faite la même chose dans l'autre fenêtre. Vous devrez recevoir ce message :

```
! [rejected]        master -> dev (fetch first)
error: failed to push some refs to 'git@gitlab.com:username/TP_initiation_git.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

Git vous signifie que votre copie locale est en retard sur la copie distante. Et comme vous êtes en retard, git ne vous permet pas de pousser vos modifications. Pour avoir le droit d'envoyer votre code sur le dépôt distant vous devez avoir en local au minimum tout l'historique de la copie distante. Récupérez ces modifications distantes avec un `git pull` puis poussez vos modifications locales.

Enfin allez récupérer ces modifications que vous venez de pousser dans l'autre fenêtre VScode. Faites un `git log --all --decorate --oneline --graph` pour voir à quoi ressemble votre historique. Vous allez constater une disjonction puis une fusion. Cette séparation correspond aux deux commits effectués en parallèle.

### Avancé

Lorsque vous maîtriserez `git pull` et la gestion de conflits (section Hands on 3 ci-dessous), vous pourrez utiliser `git pull --rebase`. Cette option permet d'éviter la disjonction / fusion inscrite dans l'historique pour n'avoir que la ligne du commit additionnel dans l'historique. L'utilisation de rebase fait partie des bonnes pratiques de git, mais son usage n'est pas nécessaire pour un débutant.

## Exercice d'application 2

- Dans une des fenêtres VScode modifiez le code de `puissance_rec.py` pour le code suivant :

  ```{.python}
  def puissance_rec_smarter(nombre, puissance):
      if not puissance:
          return 1
      elif not puissance % 2:
          return puissance_rec(nombre, int(puissance / 2))**2
      else:
          return nombre * puissance_rec(nombre, puissance - 1)
  ```

- Dans l'autre fenêtre modifiez le code de `fibonacci.py` pour que la boucle dans la condition finale aille jusqu'à 201

- Synchronisez les deux codes.

## Un premier conflit

Pour le moment vous avez travaillé sans générer le moindre conflit. Or la gestion des conflits est un élément crucial pour utiliser correctement git. Les conflits vont apparaître quand plusieurs commits faits en parallèle sont incohérents (dans le cas de fichiers textes, ceci est le cas lorsque les modifications impactent les mêmes zones de code).

Dans la première fenêtre VScode, modifiez le fichier `voiture.py` pour qu'il ressemble à :

```{.python}
class Voiture:
    def __init__(self, nom, couleur, marque):
        self.couleur = couleur
        self.nom = nom
        self.vitesse = 0
        self.marque = marque
        
    def accelere(self, increment):
        if increment > 10:
            increment = 10
        self.vitesse = min(130, self.vitesse + increment)
```

Dans la seconde, modifiez le fichier `voiture.py` pour qu'il ressemble à :

```{.python}
class Voiture:
    def __init__(self, nom, couleur, vitesse_max):
        self.couleur = couleur
        self.nom = nom
        self.vitesse = 0
        self.vitesse_max = vitesse_max
        
    def accelere(self, increment):
        if increment > 10:
            increment = 10
        self.vitesse = min(self.vitesse_max, self.vitesse + increment)
```

Vous pourrez observer que ces modifications changent la ligne avec  `__init__` de manière différente.

Maintenant faites des commits dans les deux fenêtres, un `git push` dans l'un des deux et un `git pull` dans l'autre. Vous allez obtenir le message suivant :

```
remote: Enumerating objects: 9, done.
remote: Counting objects: 100% (8/8), done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 5 (delta 3), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (5/5), 536 bytes | 15.00 KiB/s, done.
From https://gitlab.com/username/tp_initiation_git
   6bee995..a57ae91  main       -> origin/main
Auto-merging voiture.py
CONFLICT (content): Merge conflict in voiture.py
Automatic merge failed; fix conflicts and then commit the result.
```

Git vous prévient que lors de la récupération (avec `git pull`), il n'est pas arrivé à fusionner les commits automatiquement. C'est cela qu'on appel un conflit. Un conflit est généré quand les mêmes lignes de fichiers sont modifiés par deux commits de manière différente. Votre code ressemble à cela désormais :

```{.python}
class Voiture:
<<<<<<< HEAD
    def __init__(self, nom, couleur, vitesse_max):
        self.couleur = couleur
        self.nom = nom
        self.vitesse = 0
        self.vitesse_max = vitesse_max
=======
    def __init__(self, nom, couleur, marque):
        self.couleur = couleur
        self.nom = nom
        self.vitesse = 0
        self.marque = marque
>>>>>>> a57ae9120dbf97dbab78f82db81f5fc8f48f3821
        
    def accelere(self, increment):
        if increment > 10:
            increment = 10
        self.vitesse = min(self.vitesse_max, self.vitesse + increment)
```

La zone de code :

```{.python}
<<<<<<< HEAD
...
=======
...
>>>>>>> a57ae9120dbf97dbab78f82db81f5fc8f48f3821
```

est la zone du fichier en conflit. La première partie (après `<<<<<<< HEAD` mais avant `=======`) correspond au code en que vous aviez dans votre copie de travail, la seconde au code de la copie distante. Il vous faut maintenant fusionner les deux codes comme vous le souhaitez. Vous pouvez décider de ne prendre que vos changements, que les changements distant ou faire un mix des deux. Remarquez que la ligne 19 n'est pas en conflit. Cette ligne n'a été modifiée que par un seul commit donc il n'y a pas de conflit.

Avant de faire quoi que ce soit, faite un `git status`. Vous allez voir que git vous prévient que les différents historiques ont divergé, et que le fichier `voiture.py` a été modifié par les versions. C'est donc le seul fichier en conflit.

Pour le résoudre vous allez faire un mix des deux commits. le code de votre fichier sera : 

```{.python}
class Voiture:
    def __init__(self, nom, couleur, vitesse_max, marque):
        self.couleur = couleur
        self.nom = nom
        self.vitesse = 0
        self.vitesse_max = vitesse_max
        self.marque = marque
        
    def accelere(self, increment):
        if increment > 10:
            increment = 10
        self.vitesse = min(self.vitesse_max, self.vitesse + increment)
```

Faites maintenant un `git add voiture.py` puis un `git status`. Le message va vous dire que tout les conflits sont résolus, mais que vous être encore en train de faire une fusion. Il vous faut maintenant faire un commit pour mettre fin à la fusion. Faites un `git log --all --decorate --oneline --graph` pour voir à quoi ressemble votre historique après votre commit. Finalement, faites un `git push`, puis un `git pull` dans l'autre fenêtre de VSCode.

## Exercice d'application 3

- Dans une des fenêtres de VScode
  - Sur le constructeur de la classe `voiture` (la méthode `__init__`), mettez la valeur par défaut de couleur à `verte` : `def __init__(self, nom, vitesse_max, marque, couleur=verte)`
  - Créez un nouveau fichier `scooter.py` en copiant le contenu du fichier `voiture.py`
  - Modifiez la méthode `accelere()` de `scooter.py` pour avoir une vitesse maximale de 80

- Dans la seconde fenêtres de VScode
  -  Sur le constructeur de la classe `voiture` (la méthode `__init__`), mettez la valeur par défaut de couleur à `jaune`
  -  Créez un nouveau fichier `scooter.py` en copiant le contenu du fichier `voiture.py`
  -  Modifiez la méthode `accelere()` de `scooter.py` pour avoir une vitesse maximale de 75
  -  Créez un nouveau fichier `train.py` en copiant le contenu du fichier `voiture.py`
  -  Modifiez la méthode `accelere()` de `scooter.py` pour avoir une vitesse maximale de 350

- Synchronisez vos dépôts et résolvez les conflits.
